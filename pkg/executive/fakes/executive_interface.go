// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/segmentio/ctlstore/pkg/executive"
	"github.com/segmentio/ctlstore/pkg/limits"
	"github.com/segmentio/ctlstore/pkg/schema"
)

type FakeExecutiveInterface struct {
	AddFieldsStub        func(string, string, []string, []schema.FieldType) error
	addFieldsMutex       sync.RWMutex
	addFieldsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
		arg4 []schema.FieldType
	}
	addFieldsReturns struct {
		result1 error
	}
	addFieldsReturnsOnCall map[int]struct {
		result1 error
	}
	ClearTableStub        func(schema.FamilyTable) error
	clearTableMutex       sync.RWMutex
	clearTableArgsForCall []struct {
		arg1 schema.FamilyTable
	}
	clearTableReturns struct {
		result1 error
	}
	clearTableReturnsOnCall map[int]struct {
		result1 error
	}
	CreateFamilyStub        func(string) error
	createFamilyMutex       sync.RWMutex
	createFamilyArgsForCall []struct {
		arg1 string
	}
	createFamilyReturns struct {
		result1 error
	}
	createFamilyReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTableStub        func(string, string, []string, []schema.FieldType, []string) error
	createTableMutex       sync.RWMutex
	createTableArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
		arg4 []schema.FieldType
		arg5 []string
	}
	createTableReturns struct {
		result1 error
	}
	createTableReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTableSizeLimitStub        func(schema.FamilyTable) error
	deleteTableSizeLimitMutex       sync.RWMutex
	deleteTableSizeLimitArgsForCall []struct {
		arg1 schema.FamilyTable
	}
	deleteTableSizeLimitReturns struct {
		result1 error
	}
	deleteTableSizeLimitReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteWriterRateLimitStub        func(string) error
	deleteWriterRateLimitMutex       sync.RWMutex
	deleteWriterRateLimitArgsForCall []struct {
		arg1 string
	}
	deleteWriterRateLimitReturns struct {
		result1 error
	}
	deleteWriterRateLimitReturnsOnCall map[int]struct {
		result1 error
	}
	DropTableStub        func(schema.FamilyTable) error
	dropTableMutex       sync.RWMutex
	dropTableArgsForCall []struct {
		arg1 schema.FamilyTable
	}
	dropTableReturns struct {
		result1 error
	}
	dropTableReturnsOnCall map[int]struct {
		result1 error
	}
	GetWriterCookieStub        func(string, string) ([]byte, error)
	getWriterCookieMutex       sync.RWMutex
	getWriterCookieArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getWriterCookieReturns struct {
		result1 []byte
		result2 error
	}
	getWriterCookieReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	MutateStub        func(string, string, string, []byte, []byte, []executive.ExecutiveMutationRequest) error
	mutateMutex       sync.RWMutex
	mutateArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
		arg5 []byte
		arg6 []executive.ExecutiveMutationRequest
	}
	mutateReturns struct {
		result1 error
	}
	mutateReturnsOnCall map[int]struct {
		result1 error
	}
	ReadFamilyTableNamesStub        func(schema.FamilyName) ([]schema.FamilyTable, error)
	readFamilyTableNamesMutex       sync.RWMutex
	readFamilyTableNamesArgsForCall []struct {
		arg1 schema.FamilyName
	}
	readFamilyTableNamesReturns struct {
		result1 []schema.FamilyTable
		result2 error
	}
	readFamilyTableNamesReturnsOnCall map[int]struct {
		result1 []schema.FamilyTable
		result2 error
	}
	ReadRowStub        func(string, string, map[string]interface{}) (map[string]interface{}, error)
	readRowMutex       sync.RWMutex
	readRowArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 map[string]interface{}
	}
	readRowReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	readRowReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	ReadTableSizeLimitsStub        func() (limits.TableSizeLimits, error)
	readTableSizeLimitsMutex       sync.RWMutex
	readTableSizeLimitsArgsForCall []struct {
	}
	readTableSizeLimitsReturns struct {
		result1 limits.TableSizeLimits
		result2 error
	}
	readTableSizeLimitsReturnsOnCall map[int]struct {
		result1 limits.TableSizeLimits
		result2 error
	}
	ReadWriterRateLimitsStub        func() (limits.WriterRateLimits, error)
	readWriterRateLimitsMutex       sync.RWMutex
	readWriterRateLimitsArgsForCall []struct {
	}
	readWriterRateLimitsReturns struct {
		result1 limits.WriterRateLimits
		result2 error
	}
	readWriterRateLimitsReturnsOnCall map[int]struct {
		result1 limits.WriterRateLimits
		result2 error
	}
	RegisterWriterStub        func(string, string) error
	registerWriterMutex       sync.RWMutex
	registerWriterArgsForCall []struct {
		arg1 string
		arg2 string
	}
	registerWriterReturns struct {
		result1 error
	}
	registerWriterReturnsOnCall map[int]struct {
		result1 error
	}
	SetWriterCookieStub        func(string, string, []byte) error
	setWriterCookieMutex       sync.RWMutex
	setWriterCookieArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
	}
	setWriterCookieReturns struct {
		result1 error
	}
	setWriterCookieReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateTableSizeLimitStub        func(limits.TableSizeLimit) error
	updateTableSizeLimitMutex       sync.RWMutex
	updateTableSizeLimitArgsForCall []struct {
		arg1 limits.TableSizeLimit
	}
	updateTableSizeLimitReturns struct {
		result1 error
	}
	updateTableSizeLimitReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateWriterRateLimitStub        func(limits.WriterRateLimit) error
	updateWriterRateLimitMutex       sync.RWMutex
	updateWriterRateLimitArgsForCall []struct {
		arg1 limits.WriterRateLimit
	}
	updateWriterRateLimitReturns struct {
		result1 error
	}
	updateWriterRateLimitReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeExecutiveInterface) AddFields(arg1 string, arg2 string, arg3 []string, arg4 []schema.FieldType) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []schema.FieldType
	if arg4 != nil {
		arg4Copy = make([]schema.FieldType, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.addFieldsMutex.Lock()
	ret, specificReturn := fake.addFieldsReturnsOnCall[len(fake.addFieldsArgsForCall)]
	fake.addFieldsArgsForCall = append(fake.addFieldsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
		arg4 []schema.FieldType
	}{arg1, arg2, arg3Copy, arg4Copy})
	fake.recordInvocation("AddFields", []interface{}{arg1, arg2, arg3Copy, arg4Copy})
	fake.addFieldsMutex.Unlock()
	if fake.AddFieldsStub != nil {
		return fake.AddFieldsStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addFieldsReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) AddFieldsCallCount() int {
	fake.addFieldsMutex.RLock()
	defer fake.addFieldsMutex.RUnlock()
	return len(fake.addFieldsArgsForCall)
}

func (fake *FakeExecutiveInterface) AddFieldsCalls(stub func(string, string, []string, []schema.FieldType) error) {
	fake.addFieldsMutex.Lock()
	defer fake.addFieldsMutex.Unlock()
	fake.AddFieldsStub = stub
}

func (fake *FakeExecutiveInterface) AddFieldsArgsForCall(i int) (string, string, []string, []schema.FieldType) {
	fake.addFieldsMutex.RLock()
	defer fake.addFieldsMutex.RUnlock()
	argsForCall := fake.addFieldsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeExecutiveInterface) AddFieldsReturns(result1 error) {
	fake.addFieldsMutex.Lock()
	defer fake.addFieldsMutex.Unlock()
	fake.AddFieldsStub = nil
	fake.addFieldsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) AddFieldsReturnsOnCall(i int, result1 error) {
	fake.addFieldsMutex.Lock()
	defer fake.addFieldsMutex.Unlock()
	fake.AddFieldsStub = nil
	if fake.addFieldsReturnsOnCall == nil {
		fake.addFieldsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFieldsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) ClearTable(arg1 schema.FamilyTable) error {
	fake.clearTableMutex.Lock()
	ret, specificReturn := fake.clearTableReturnsOnCall[len(fake.clearTableArgsForCall)]
	fake.clearTableArgsForCall = append(fake.clearTableArgsForCall, struct {
		arg1 schema.FamilyTable
	}{arg1})
	fake.recordInvocation("ClearTable", []interface{}{arg1})
	fake.clearTableMutex.Unlock()
	if fake.ClearTableStub != nil {
		return fake.ClearTableStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clearTableReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) ClearTableCallCount() int {
	fake.clearTableMutex.RLock()
	defer fake.clearTableMutex.RUnlock()
	return len(fake.clearTableArgsForCall)
}

func (fake *FakeExecutiveInterface) ClearTableCalls(stub func(schema.FamilyTable) error) {
	fake.clearTableMutex.Lock()
	defer fake.clearTableMutex.Unlock()
	fake.ClearTableStub = stub
}

func (fake *FakeExecutiveInterface) ClearTableArgsForCall(i int) schema.FamilyTable {
	fake.clearTableMutex.RLock()
	defer fake.clearTableMutex.RUnlock()
	argsForCall := fake.clearTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutiveInterface) ClearTableReturns(result1 error) {
	fake.clearTableMutex.Lock()
	defer fake.clearTableMutex.Unlock()
	fake.ClearTableStub = nil
	fake.clearTableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) ClearTableReturnsOnCall(i int, result1 error) {
	fake.clearTableMutex.Lock()
	defer fake.clearTableMutex.Unlock()
	fake.ClearTableStub = nil
	if fake.clearTableReturnsOnCall == nil {
		fake.clearTableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearTableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) CreateFamily(arg1 string) error {
	fake.createFamilyMutex.Lock()
	ret, specificReturn := fake.createFamilyReturnsOnCall[len(fake.createFamilyArgsForCall)]
	fake.createFamilyArgsForCall = append(fake.createFamilyArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateFamily", []interface{}{arg1})
	fake.createFamilyMutex.Unlock()
	if fake.CreateFamilyStub != nil {
		return fake.CreateFamilyStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createFamilyReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) CreateFamilyCallCount() int {
	fake.createFamilyMutex.RLock()
	defer fake.createFamilyMutex.RUnlock()
	return len(fake.createFamilyArgsForCall)
}

func (fake *FakeExecutiveInterface) CreateFamilyCalls(stub func(string) error) {
	fake.createFamilyMutex.Lock()
	defer fake.createFamilyMutex.Unlock()
	fake.CreateFamilyStub = stub
}

func (fake *FakeExecutiveInterface) CreateFamilyArgsForCall(i int) string {
	fake.createFamilyMutex.RLock()
	defer fake.createFamilyMutex.RUnlock()
	argsForCall := fake.createFamilyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutiveInterface) CreateFamilyReturns(result1 error) {
	fake.createFamilyMutex.Lock()
	defer fake.createFamilyMutex.Unlock()
	fake.CreateFamilyStub = nil
	fake.createFamilyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) CreateFamilyReturnsOnCall(i int, result1 error) {
	fake.createFamilyMutex.Lock()
	defer fake.createFamilyMutex.Unlock()
	fake.CreateFamilyStub = nil
	if fake.createFamilyReturnsOnCall == nil {
		fake.createFamilyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createFamilyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) CreateTable(arg1 string, arg2 string, arg3 []string, arg4 []schema.FieldType, arg5 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []schema.FieldType
	if arg4 != nil {
		arg4Copy = make([]schema.FieldType, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.createTableMutex.Lock()
	ret, specificReturn := fake.createTableReturnsOnCall[len(fake.createTableArgsForCall)]
	fake.createTableArgsForCall = append(fake.createTableArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
		arg4 []schema.FieldType
		arg5 []string
	}{arg1, arg2, arg3Copy, arg4Copy, arg5Copy})
	fake.recordInvocation("CreateTable", []interface{}{arg1, arg2, arg3Copy, arg4Copy, arg5Copy})
	fake.createTableMutex.Unlock()
	if fake.CreateTableStub != nil {
		return fake.CreateTableStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createTableReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) CreateTableCallCount() int {
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	return len(fake.createTableArgsForCall)
}

func (fake *FakeExecutiveInterface) CreateTableCalls(stub func(string, string, []string, []schema.FieldType, []string) error) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = stub
}

func (fake *FakeExecutiveInterface) CreateTableArgsForCall(i int) (string, string, []string, []schema.FieldType, []string) {
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	argsForCall := fake.createTableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeExecutiveInterface) CreateTableReturns(result1 error) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = nil
	fake.createTableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) CreateTableReturnsOnCall(i int, result1 error) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = nil
	if fake.createTableReturnsOnCall == nil {
		fake.createTableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) DeleteTableSizeLimit(arg1 schema.FamilyTable) error {
	fake.deleteTableSizeLimitMutex.Lock()
	ret, specificReturn := fake.deleteTableSizeLimitReturnsOnCall[len(fake.deleteTableSizeLimitArgsForCall)]
	fake.deleteTableSizeLimitArgsForCall = append(fake.deleteTableSizeLimitArgsForCall, struct {
		arg1 schema.FamilyTable
	}{arg1})
	fake.recordInvocation("DeleteTableSizeLimit", []interface{}{arg1})
	fake.deleteTableSizeLimitMutex.Unlock()
	if fake.DeleteTableSizeLimitStub != nil {
		return fake.DeleteTableSizeLimitStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteTableSizeLimitReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) DeleteTableSizeLimitCallCount() int {
	fake.deleteTableSizeLimitMutex.RLock()
	defer fake.deleteTableSizeLimitMutex.RUnlock()
	return len(fake.deleteTableSizeLimitArgsForCall)
}

func (fake *FakeExecutiveInterface) DeleteTableSizeLimitCalls(stub func(schema.FamilyTable) error) {
	fake.deleteTableSizeLimitMutex.Lock()
	defer fake.deleteTableSizeLimitMutex.Unlock()
	fake.DeleteTableSizeLimitStub = stub
}

func (fake *FakeExecutiveInterface) DeleteTableSizeLimitArgsForCall(i int) schema.FamilyTable {
	fake.deleteTableSizeLimitMutex.RLock()
	defer fake.deleteTableSizeLimitMutex.RUnlock()
	argsForCall := fake.deleteTableSizeLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutiveInterface) DeleteTableSizeLimitReturns(result1 error) {
	fake.deleteTableSizeLimitMutex.Lock()
	defer fake.deleteTableSizeLimitMutex.Unlock()
	fake.DeleteTableSizeLimitStub = nil
	fake.deleteTableSizeLimitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) DeleteTableSizeLimitReturnsOnCall(i int, result1 error) {
	fake.deleteTableSizeLimitMutex.Lock()
	defer fake.deleteTableSizeLimitMutex.Unlock()
	fake.DeleteTableSizeLimitStub = nil
	if fake.deleteTableSizeLimitReturnsOnCall == nil {
		fake.deleteTableSizeLimitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTableSizeLimitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) DeleteWriterRateLimit(arg1 string) error {
	fake.deleteWriterRateLimitMutex.Lock()
	ret, specificReturn := fake.deleteWriterRateLimitReturnsOnCall[len(fake.deleteWriterRateLimitArgsForCall)]
	fake.deleteWriterRateLimitArgsForCall = append(fake.deleteWriterRateLimitArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteWriterRateLimit", []interface{}{arg1})
	fake.deleteWriterRateLimitMutex.Unlock()
	if fake.DeleteWriterRateLimitStub != nil {
		return fake.DeleteWriterRateLimitStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteWriterRateLimitReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) DeleteWriterRateLimitCallCount() int {
	fake.deleteWriterRateLimitMutex.RLock()
	defer fake.deleteWriterRateLimitMutex.RUnlock()
	return len(fake.deleteWriterRateLimitArgsForCall)
}

func (fake *FakeExecutiveInterface) DeleteWriterRateLimitCalls(stub func(string) error) {
	fake.deleteWriterRateLimitMutex.Lock()
	defer fake.deleteWriterRateLimitMutex.Unlock()
	fake.DeleteWriterRateLimitStub = stub
}

func (fake *FakeExecutiveInterface) DeleteWriterRateLimitArgsForCall(i int) string {
	fake.deleteWriterRateLimitMutex.RLock()
	defer fake.deleteWriterRateLimitMutex.RUnlock()
	argsForCall := fake.deleteWriterRateLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutiveInterface) DeleteWriterRateLimitReturns(result1 error) {
	fake.deleteWriterRateLimitMutex.Lock()
	defer fake.deleteWriterRateLimitMutex.Unlock()
	fake.DeleteWriterRateLimitStub = nil
	fake.deleteWriterRateLimitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) DeleteWriterRateLimitReturnsOnCall(i int, result1 error) {
	fake.deleteWriterRateLimitMutex.Lock()
	defer fake.deleteWriterRateLimitMutex.Unlock()
	fake.DeleteWriterRateLimitStub = nil
	if fake.deleteWriterRateLimitReturnsOnCall == nil {
		fake.deleteWriterRateLimitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteWriterRateLimitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) DropTable(arg1 schema.FamilyTable) error {
	fake.dropTableMutex.Lock()
	ret, specificReturn := fake.dropTableReturnsOnCall[len(fake.dropTableArgsForCall)]
	fake.dropTableArgsForCall = append(fake.dropTableArgsForCall, struct {
		arg1 schema.FamilyTable
	}{arg1})
	fake.recordInvocation("DropTable", []interface{}{arg1})
	fake.dropTableMutex.Unlock()
	if fake.DropTableStub != nil {
		return fake.DropTableStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dropTableReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) DropTableCallCount() int {
	fake.dropTableMutex.RLock()
	defer fake.dropTableMutex.RUnlock()
	return len(fake.dropTableArgsForCall)
}

func (fake *FakeExecutiveInterface) DropTableCalls(stub func(schema.FamilyTable) error) {
	fake.dropTableMutex.Lock()
	defer fake.dropTableMutex.Unlock()
	fake.DropTableStub = stub
}

func (fake *FakeExecutiveInterface) DropTableArgsForCall(i int) schema.FamilyTable {
	fake.dropTableMutex.RLock()
	defer fake.dropTableMutex.RUnlock()
	argsForCall := fake.dropTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutiveInterface) DropTableReturns(result1 error) {
	fake.dropTableMutex.Lock()
	defer fake.dropTableMutex.Unlock()
	fake.DropTableStub = nil
	fake.dropTableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) DropTableReturnsOnCall(i int, result1 error) {
	fake.dropTableMutex.Lock()
	defer fake.dropTableMutex.Unlock()
	fake.DropTableStub = nil
	if fake.dropTableReturnsOnCall == nil {
		fake.dropTableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dropTableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) GetWriterCookie(arg1 string, arg2 string) ([]byte, error) {
	fake.getWriterCookieMutex.Lock()
	ret, specificReturn := fake.getWriterCookieReturnsOnCall[len(fake.getWriterCookieArgsForCall)]
	fake.getWriterCookieArgsForCall = append(fake.getWriterCookieArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetWriterCookie", []interface{}{arg1, arg2})
	fake.getWriterCookieMutex.Unlock()
	if fake.GetWriterCookieStub != nil {
		return fake.GetWriterCookieStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getWriterCookieReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutiveInterface) GetWriterCookieCallCount() int {
	fake.getWriterCookieMutex.RLock()
	defer fake.getWriterCookieMutex.RUnlock()
	return len(fake.getWriterCookieArgsForCall)
}

func (fake *FakeExecutiveInterface) GetWriterCookieCalls(stub func(string, string) ([]byte, error)) {
	fake.getWriterCookieMutex.Lock()
	defer fake.getWriterCookieMutex.Unlock()
	fake.GetWriterCookieStub = stub
}

func (fake *FakeExecutiveInterface) GetWriterCookieArgsForCall(i int) (string, string) {
	fake.getWriterCookieMutex.RLock()
	defer fake.getWriterCookieMutex.RUnlock()
	argsForCall := fake.getWriterCookieArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExecutiveInterface) GetWriterCookieReturns(result1 []byte, result2 error) {
	fake.getWriterCookieMutex.Lock()
	defer fake.getWriterCookieMutex.Unlock()
	fake.GetWriterCookieStub = nil
	fake.getWriterCookieReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) GetWriterCookieReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getWriterCookieMutex.Lock()
	defer fake.getWriterCookieMutex.Unlock()
	fake.GetWriterCookieStub = nil
	if fake.getWriterCookieReturnsOnCall == nil {
		fake.getWriterCookieReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getWriterCookieReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) Mutate(arg1 string, arg2 string, arg3 string, arg4 []byte, arg5 []byte, arg6 []executive.ExecutiveMutationRequest) error {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []byte
	if arg5 != nil {
		arg5Copy = make([]byte, len(arg5))
		copy(arg5Copy, arg5)
	}
	var arg6Copy []executive.ExecutiveMutationRequest
	if arg6 != nil {
		arg6Copy = make([]executive.ExecutiveMutationRequest, len(arg6))
		copy(arg6Copy, arg6)
	}
	fake.mutateMutex.Lock()
	ret, specificReturn := fake.mutateReturnsOnCall[len(fake.mutateArgsForCall)]
	fake.mutateArgsForCall = append(fake.mutateArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
		arg5 []byte
		arg6 []executive.ExecutiveMutationRequest
	}{arg1, arg2, arg3, arg4Copy, arg5Copy, arg6Copy})
	fake.recordInvocation("Mutate", []interface{}{arg1, arg2, arg3, arg4Copy, arg5Copy, arg6Copy})
	fake.mutateMutex.Unlock()
	if fake.MutateStub != nil {
		return fake.MutateStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mutateReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) MutateCallCount() int {
	fake.mutateMutex.RLock()
	defer fake.mutateMutex.RUnlock()
	return len(fake.mutateArgsForCall)
}

func (fake *FakeExecutiveInterface) MutateCalls(stub func(string, string, string, []byte, []byte, []executive.ExecutiveMutationRequest) error) {
	fake.mutateMutex.Lock()
	defer fake.mutateMutex.Unlock()
	fake.MutateStub = stub
}

func (fake *FakeExecutiveInterface) MutateArgsForCall(i int) (string, string, string, []byte, []byte, []executive.ExecutiveMutationRequest) {
	fake.mutateMutex.RLock()
	defer fake.mutateMutex.RUnlock()
	argsForCall := fake.mutateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeExecutiveInterface) MutateReturns(result1 error) {
	fake.mutateMutex.Lock()
	defer fake.mutateMutex.Unlock()
	fake.MutateStub = nil
	fake.mutateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) MutateReturnsOnCall(i int, result1 error) {
	fake.mutateMutex.Lock()
	defer fake.mutateMutex.Unlock()
	fake.MutateStub = nil
	if fake.mutateReturnsOnCall == nil {
		fake.mutateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mutateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) ReadFamilyTableNames(arg1 schema.FamilyName) ([]schema.FamilyTable, error) {
	fake.readFamilyTableNamesMutex.Lock()
	ret, specificReturn := fake.readFamilyTableNamesReturnsOnCall[len(fake.readFamilyTableNamesArgsForCall)]
	fake.readFamilyTableNamesArgsForCall = append(fake.readFamilyTableNamesArgsForCall, struct {
		arg1 schema.FamilyName
	}{arg1})
	fake.recordInvocation("ReadFamilyTableNames", []interface{}{arg1})
	fake.readFamilyTableNamesMutex.Unlock()
	if fake.ReadFamilyTableNamesStub != nil {
		return fake.ReadFamilyTableNamesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readFamilyTableNamesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutiveInterface) ReadFamilyTableNamesCallCount() int {
	fake.readFamilyTableNamesMutex.RLock()
	defer fake.readFamilyTableNamesMutex.RUnlock()
	return len(fake.readFamilyTableNamesArgsForCall)
}

func (fake *FakeExecutiveInterface) ReadFamilyTableNamesCalls(stub func(schema.FamilyName) ([]schema.FamilyTable, error)) {
	fake.readFamilyTableNamesMutex.Lock()
	defer fake.readFamilyTableNamesMutex.Unlock()
	fake.ReadFamilyTableNamesStub = stub
}

func (fake *FakeExecutiveInterface) ReadFamilyTableNamesArgsForCall(i int) schema.FamilyName {
	fake.readFamilyTableNamesMutex.RLock()
	defer fake.readFamilyTableNamesMutex.RUnlock()
	argsForCall := fake.readFamilyTableNamesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutiveInterface) ReadFamilyTableNamesReturns(result1 []schema.FamilyTable, result2 error) {
	fake.readFamilyTableNamesMutex.Lock()
	defer fake.readFamilyTableNamesMutex.Unlock()
	fake.ReadFamilyTableNamesStub = nil
	fake.readFamilyTableNamesReturns = struct {
		result1 []schema.FamilyTable
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) ReadFamilyTableNamesReturnsOnCall(i int, result1 []schema.FamilyTable, result2 error) {
	fake.readFamilyTableNamesMutex.Lock()
	defer fake.readFamilyTableNamesMutex.Unlock()
	fake.ReadFamilyTableNamesStub = nil
	if fake.readFamilyTableNamesReturnsOnCall == nil {
		fake.readFamilyTableNamesReturnsOnCall = make(map[int]struct {
			result1 []schema.FamilyTable
			result2 error
		})
	}
	fake.readFamilyTableNamesReturnsOnCall[i] = struct {
		result1 []schema.FamilyTable
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) ReadRow(arg1 string, arg2 string, arg3 map[string]interface{}) (map[string]interface{}, error) {
	fake.readRowMutex.Lock()
	ret, specificReturn := fake.readRowReturnsOnCall[len(fake.readRowArgsForCall)]
	fake.readRowArgsForCall = append(fake.readRowArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 map[string]interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("ReadRow", []interface{}{arg1, arg2, arg3})
	fake.readRowMutex.Unlock()
	if fake.ReadRowStub != nil {
		return fake.ReadRowStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readRowReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutiveInterface) ReadRowCallCount() int {
	fake.readRowMutex.RLock()
	defer fake.readRowMutex.RUnlock()
	return len(fake.readRowArgsForCall)
}

func (fake *FakeExecutiveInterface) ReadRowCalls(stub func(string, string, map[string]interface{}) (map[string]interface{}, error)) {
	fake.readRowMutex.Lock()
	defer fake.readRowMutex.Unlock()
	fake.ReadRowStub = stub
}

func (fake *FakeExecutiveInterface) ReadRowArgsForCall(i int) (string, string, map[string]interface{}) {
	fake.readRowMutex.RLock()
	defer fake.readRowMutex.RUnlock()
	argsForCall := fake.readRowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeExecutiveInterface) ReadRowReturns(result1 map[string]interface{}, result2 error) {
	fake.readRowMutex.Lock()
	defer fake.readRowMutex.Unlock()
	fake.ReadRowStub = nil
	fake.readRowReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) ReadRowReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.readRowMutex.Lock()
	defer fake.readRowMutex.Unlock()
	fake.ReadRowStub = nil
	if fake.readRowReturnsOnCall == nil {
		fake.readRowReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.readRowReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) ReadTableSizeLimits() (limits.TableSizeLimits, error) {
	fake.readTableSizeLimitsMutex.Lock()
	ret, specificReturn := fake.readTableSizeLimitsReturnsOnCall[len(fake.readTableSizeLimitsArgsForCall)]
	fake.readTableSizeLimitsArgsForCall = append(fake.readTableSizeLimitsArgsForCall, struct {
	}{})
	fake.recordInvocation("ReadTableSizeLimits", []interface{}{})
	fake.readTableSizeLimitsMutex.Unlock()
	if fake.ReadTableSizeLimitsStub != nil {
		return fake.ReadTableSizeLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readTableSizeLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutiveInterface) ReadTableSizeLimitsCallCount() int {
	fake.readTableSizeLimitsMutex.RLock()
	defer fake.readTableSizeLimitsMutex.RUnlock()
	return len(fake.readTableSizeLimitsArgsForCall)
}

func (fake *FakeExecutiveInterface) ReadTableSizeLimitsCalls(stub func() (limits.TableSizeLimits, error)) {
	fake.readTableSizeLimitsMutex.Lock()
	defer fake.readTableSizeLimitsMutex.Unlock()
	fake.ReadTableSizeLimitsStub = stub
}

func (fake *FakeExecutiveInterface) ReadTableSizeLimitsReturns(result1 limits.TableSizeLimits, result2 error) {
	fake.readTableSizeLimitsMutex.Lock()
	defer fake.readTableSizeLimitsMutex.Unlock()
	fake.ReadTableSizeLimitsStub = nil
	fake.readTableSizeLimitsReturns = struct {
		result1 limits.TableSizeLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) ReadTableSizeLimitsReturnsOnCall(i int, result1 limits.TableSizeLimits, result2 error) {
	fake.readTableSizeLimitsMutex.Lock()
	defer fake.readTableSizeLimitsMutex.Unlock()
	fake.ReadTableSizeLimitsStub = nil
	if fake.readTableSizeLimitsReturnsOnCall == nil {
		fake.readTableSizeLimitsReturnsOnCall = make(map[int]struct {
			result1 limits.TableSizeLimits
			result2 error
		})
	}
	fake.readTableSizeLimitsReturnsOnCall[i] = struct {
		result1 limits.TableSizeLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) ReadWriterRateLimits() (limits.WriterRateLimits, error) {
	fake.readWriterRateLimitsMutex.Lock()
	ret, specificReturn := fake.readWriterRateLimitsReturnsOnCall[len(fake.readWriterRateLimitsArgsForCall)]
	fake.readWriterRateLimitsArgsForCall = append(fake.readWriterRateLimitsArgsForCall, struct {
	}{})
	fake.recordInvocation("ReadWriterRateLimits", []interface{}{})
	fake.readWriterRateLimitsMutex.Unlock()
	if fake.ReadWriterRateLimitsStub != nil {
		return fake.ReadWriterRateLimitsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readWriterRateLimitsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutiveInterface) ReadWriterRateLimitsCallCount() int {
	fake.readWriterRateLimitsMutex.RLock()
	defer fake.readWriterRateLimitsMutex.RUnlock()
	return len(fake.readWriterRateLimitsArgsForCall)
}

func (fake *FakeExecutiveInterface) ReadWriterRateLimitsCalls(stub func() (limits.WriterRateLimits, error)) {
	fake.readWriterRateLimitsMutex.Lock()
	defer fake.readWriterRateLimitsMutex.Unlock()
	fake.ReadWriterRateLimitsStub = stub
}

func (fake *FakeExecutiveInterface) ReadWriterRateLimitsReturns(result1 limits.WriterRateLimits, result2 error) {
	fake.readWriterRateLimitsMutex.Lock()
	defer fake.readWriterRateLimitsMutex.Unlock()
	fake.ReadWriterRateLimitsStub = nil
	fake.readWriterRateLimitsReturns = struct {
		result1 limits.WriterRateLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) ReadWriterRateLimitsReturnsOnCall(i int, result1 limits.WriterRateLimits, result2 error) {
	fake.readWriterRateLimitsMutex.Lock()
	defer fake.readWriterRateLimitsMutex.Unlock()
	fake.ReadWriterRateLimitsStub = nil
	if fake.readWriterRateLimitsReturnsOnCall == nil {
		fake.readWriterRateLimitsReturnsOnCall = make(map[int]struct {
			result1 limits.WriterRateLimits
			result2 error
		})
	}
	fake.readWriterRateLimitsReturnsOnCall[i] = struct {
		result1 limits.WriterRateLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutiveInterface) RegisterWriter(arg1 string, arg2 string) error {
	fake.registerWriterMutex.Lock()
	ret, specificReturn := fake.registerWriterReturnsOnCall[len(fake.registerWriterArgsForCall)]
	fake.registerWriterArgsForCall = append(fake.registerWriterArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RegisterWriter", []interface{}{arg1, arg2})
	fake.registerWriterMutex.Unlock()
	if fake.RegisterWriterStub != nil {
		return fake.RegisterWriterStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.registerWriterReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) RegisterWriterCallCount() int {
	fake.registerWriterMutex.RLock()
	defer fake.registerWriterMutex.RUnlock()
	return len(fake.registerWriterArgsForCall)
}

func (fake *FakeExecutiveInterface) RegisterWriterCalls(stub func(string, string) error) {
	fake.registerWriterMutex.Lock()
	defer fake.registerWriterMutex.Unlock()
	fake.RegisterWriterStub = stub
}

func (fake *FakeExecutiveInterface) RegisterWriterArgsForCall(i int) (string, string) {
	fake.registerWriterMutex.RLock()
	defer fake.registerWriterMutex.RUnlock()
	argsForCall := fake.registerWriterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExecutiveInterface) RegisterWriterReturns(result1 error) {
	fake.registerWriterMutex.Lock()
	defer fake.registerWriterMutex.Unlock()
	fake.RegisterWriterStub = nil
	fake.registerWriterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) RegisterWriterReturnsOnCall(i int, result1 error) {
	fake.registerWriterMutex.Lock()
	defer fake.registerWriterMutex.Unlock()
	fake.RegisterWriterStub = nil
	if fake.registerWriterReturnsOnCall == nil {
		fake.registerWriterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerWriterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) SetWriterCookie(arg1 string, arg2 string, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.setWriterCookieMutex.Lock()
	ret, specificReturn := fake.setWriterCookieReturnsOnCall[len(fake.setWriterCookieArgsForCall)]
	fake.setWriterCookieArgsForCall = append(fake.setWriterCookieArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("SetWriterCookie", []interface{}{arg1, arg2, arg3Copy})
	fake.setWriterCookieMutex.Unlock()
	if fake.SetWriterCookieStub != nil {
		return fake.SetWriterCookieStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setWriterCookieReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) SetWriterCookieCallCount() int {
	fake.setWriterCookieMutex.RLock()
	defer fake.setWriterCookieMutex.RUnlock()
	return len(fake.setWriterCookieArgsForCall)
}

func (fake *FakeExecutiveInterface) SetWriterCookieCalls(stub func(string, string, []byte) error) {
	fake.setWriterCookieMutex.Lock()
	defer fake.setWriterCookieMutex.Unlock()
	fake.SetWriterCookieStub = stub
}

func (fake *FakeExecutiveInterface) SetWriterCookieArgsForCall(i int) (string, string, []byte) {
	fake.setWriterCookieMutex.RLock()
	defer fake.setWriterCookieMutex.RUnlock()
	argsForCall := fake.setWriterCookieArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeExecutiveInterface) SetWriterCookieReturns(result1 error) {
	fake.setWriterCookieMutex.Lock()
	defer fake.setWriterCookieMutex.Unlock()
	fake.SetWriterCookieStub = nil
	fake.setWriterCookieReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) SetWriterCookieReturnsOnCall(i int, result1 error) {
	fake.setWriterCookieMutex.Lock()
	defer fake.setWriterCookieMutex.Unlock()
	fake.SetWriterCookieStub = nil
	if fake.setWriterCookieReturnsOnCall == nil {
		fake.setWriterCookieReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setWriterCookieReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) UpdateTableSizeLimit(arg1 limits.TableSizeLimit) error {
	fake.updateTableSizeLimitMutex.Lock()
	ret, specificReturn := fake.updateTableSizeLimitReturnsOnCall[len(fake.updateTableSizeLimitArgsForCall)]
	fake.updateTableSizeLimitArgsForCall = append(fake.updateTableSizeLimitArgsForCall, struct {
		arg1 limits.TableSizeLimit
	}{arg1})
	fake.recordInvocation("UpdateTableSizeLimit", []interface{}{arg1})
	fake.updateTableSizeLimitMutex.Unlock()
	if fake.UpdateTableSizeLimitStub != nil {
		return fake.UpdateTableSizeLimitStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateTableSizeLimitReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) UpdateTableSizeLimitCallCount() int {
	fake.updateTableSizeLimitMutex.RLock()
	defer fake.updateTableSizeLimitMutex.RUnlock()
	return len(fake.updateTableSizeLimitArgsForCall)
}

func (fake *FakeExecutiveInterface) UpdateTableSizeLimitCalls(stub func(limits.TableSizeLimit) error) {
	fake.updateTableSizeLimitMutex.Lock()
	defer fake.updateTableSizeLimitMutex.Unlock()
	fake.UpdateTableSizeLimitStub = stub
}

func (fake *FakeExecutiveInterface) UpdateTableSizeLimitArgsForCall(i int) limits.TableSizeLimit {
	fake.updateTableSizeLimitMutex.RLock()
	defer fake.updateTableSizeLimitMutex.RUnlock()
	argsForCall := fake.updateTableSizeLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutiveInterface) UpdateTableSizeLimitReturns(result1 error) {
	fake.updateTableSizeLimitMutex.Lock()
	defer fake.updateTableSizeLimitMutex.Unlock()
	fake.UpdateTableSizeLimitStub = nil
	fake.updateTableSizeLimitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) UpdateTableSizeLimitReturnsOnCall(i int, result1 error) {
	fake.updateTableSizeLimitMutex.Lock()
	defer fake.updateTableSizeLimitMutex.Unlock()
	fake.UpdateTableSizeLimitStub = nil
	if fake.updateTableSizeLimitReturnsOnCall == nil {
		fake.updateTableSizeLimitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTableSizeLimitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) UpdateWriterRateLimit(arg1 limits.WriterRateLimit) error {
	fake.updateWriterRateLimitMutex.Lock()
	ret, specificReturn := fake.updateWriterRateLimitReturnsOnCall[len(fake.updateWriterRateLimitArgsForCall)]
	fake.updateWriterRateLimitArgsForCall = append(fake.updateWriterRateLimitArgsForCall, struct {
		arg1 limits.WriterRateLimit
	}{arg1})
	fake.recordInvocation("UpdateWriterRateLimit", []interface{}{arg1})
	fake.updateWriterRateLimitMutex.Unlock()
	if fake.UpdateWriterRateLimitStub != nil {
		return fake.UpdateWriterRateLimitStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateWriterRateLimitReturns
	return fakeReturns.result1
}

func (fake *FakeExecutiveInterface) UpdateWriterRateLimitCallCount() int {
	fake.updateWriterRateLimitMutex.RLock()
	defer fake.updateWriterRateLimitMutex.RUnlock()
	return len(fake.updateWriterRateLimitArgsForCall)
}

func (fake *FakeExecutiveInterface) UpdateWriterRateLimitCalls(stub func(limits.WriterRateLimit) error) {
	fake.updateWriterRateLimitMutex.Lock()
	defer fake.updateWriterRateLimitMutex.Unlock()
	fake.UpdateWriterRateLimitStub = stub
}

func (fake *FakeExecutiveInterface) UpdateWriterRateLimitArgsForCall(i int) limits.WriterRateLimit {
	fake.updateWriterRateLimitMutex.RLock()
	defer fake.updateWriterRateLimitMutex.RUnlock()
	argsForCall := fake.updateWriterRateLimitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutiveInterface) UpdateWriterRateLimitReturns(result1 error) {
	fake.updateWriterRateLimitMutex.Lock()
	defer fake.updateWriterRateLimitMutex.Unlock()
	fake.UpdateWriterRateLimitStub = nil
	fake.updateWriterRateLimitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) UpdateWriterRateLimitReturnsOnCall(i int, result1 error) {
	fake.updateWriterRateLimitMutex.Lock()
	defer fake.updateWriterRateLimitMutex.Unlock()
	fake.UpdateWriterRateLimitStub = nil
	if fake.updateWriterRateLimitReturnsOnCall == nil {
		fake.updateWriterRateLimitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateWriterRateLimitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutiveInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addFieldsMutex.RLock()
	defer fake.addFieldsMutex.RUnlock()
	fake.clearTableMutex.RLock()
	defer fake.clearTableMutex.RUnlock()
	fake.createFamilyMutex.RLock()
	defer fake.createFamilyMutex.RUnlock()
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	fake.deleteTableSizeLimitMutex.RLock()
	defer fake.deleteTableSizeLimitMutex.RUnlock()
	fake.deleteWriterRateLimitMutex.RLock()
	defer fake.deleteWriterRateLimitMutex.RUnlock()
	fake.dropTableMutex.RLock()
	defer fake.dropTableMutex.RUnlock()
	fake.getWriterCookieMutex.RLock()
	defer fake.getWriterCookieMutex.RUnlock()
	fake.mutateMutex.RLock()
	defer fake.mutateMutex.RUnlock()
	fake.readFamilyTableNamesMutex.RLock()
	defer fake.readFamilyTableNamesMutex.RUnlock()
	fake.readRowMutex.RLock()
	defer fake.readRowMutex.RUnlock()
	fake.readTableSizeLimitsMutex.RLock()
	defer fake.readTableSizeLimitsMutex.RUnlock()
	fake.readWriterRateLimitsMutex.RLock()
	defer fake.readWriterRateLimitsMutex.RUnlock()
	fake.registerWriterMutex.RLock()
	defer fake.registerWriterMutex.RUnlock()
	fake.setWriterCookieMutex.RLock()
	defer fake.setWriterCookieMutex.RUnlock()
	fake.updateTableSizeLimitMutex.RLock()
	defer fake.updateTableSizeLimitMutex.RUnlock()
	fake.updateWriterRateLimitMutex.RLock()
	defer fake.updateWriterRateLimitMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeExecutiveInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ executive.ExecutiveInterface = new(FakeExecutiveInterface)
